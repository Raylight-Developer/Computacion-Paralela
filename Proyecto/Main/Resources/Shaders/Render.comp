//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#version 460
#include "Globals.comp"
#include "Inputs.comp"
#include "Utilities.comp"
#include "Random.comp"
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------


bool f_raySphereIntersection(in Ray ray, in vec3 sphere, out float t) {
	vec3 CO = ray.origin - sphere;
	float a = dot(ray.direction, ray.direction);
	float b = 2.0*dot(ray.direction, CO);
	float c = dot(CO, CO) - sphere_radius*sphere_radius;
	float delta = b*b - 4.0*a*c;
	if(delta < 0.0) {
		return false;
	}
	t = (-b-sqrt(delta)) / (2.0*a);
	return true;
}

bool f_rayBvhIntersection(in Ray ray, in vec3 box_min, in vec3 box_max, inout float ray_length) {
	vec3 t0 = (box_min - ray.origin) * ray.direction;
	vec3 t1 = (box_max - ray.origin) * ray.direction;

	float tmin = max(max(min(t0.x, t1.x), min(t0.y, t1.y)), min(t0.z, t1.z));
	float tmax = min(min(max(t0.x, t1.x), max(t0.y, t1.y)), max(t0.z, t1.z));

	if (all(greaterThanEqual(ray.origin, box_min)) && all(lessThanEqual(ray.origin, box_max))) {
		ray_length = tmax;
		return true;
	}
	else if (tmin <= tmax) {
		ray_length = tmin;
		return true;
	}
	return false;
}

Ray f_cameraRay(vec2 uv) {
	return Ray(camera_pos, normalize(camera_p_uv + (camera_p_u * uv.x) + (camera_p_v * uv.y) - camera_pos));
}

void main() {
	ivec2 pixel_id = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (pixel_id - 1 - vec2(resolution) / 2.0) / float(max(resolution.x, resolution.y));

	Ray ray = f_cameraRay(uv);

	float t_length = MAX_DIST;
	vec4 color = vec4(0,0,0,1);
	int grid_width = 2 * grid_size.x;
	int grid_height = 2 * grid_size.y;
	for (int x = 0; x < grid_size.x; x++) {
		for (int y = 0; y < grid_size.y; y++) {
			uint index = x * grid_size.y * 2 + y;
			float t_dist = MAX_DIST;
			if (f_raySphereIntersection(ray, point_cloud[index].pos.xyz, t_dist)) {
				if (t_dist < t_length && t_dist > EPSILON) {
					t_length = t_dist;
					color = point_cloud[index].col;
				}
			}
		}
	}

	imageStore(raw_render_layer, pixel_id, color);
}